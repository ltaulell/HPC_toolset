#!/usr/bin/env python3
# coding: utf-8
#
# $Id: ibmapviz.py 3040 2020-11-16 16:48:18Z ltaulell $
# SPDX-License-Identifier: BSD-2-Clause
#

#
# some code from ibtopotool, Copyright (C) 2013-2019  Janne Blomqvist (GPLv3+, then MPL2)
# some code from ibtoviz, Copyright (C) 2020 Jan de Cuveland (No license specified)
#


"""
create dot file from infiniband topology, hostname mapping and spines switchs
forget graphviz, pydot, pygraphviz or networkx and other *[dot,viz]*-libs:
    None have full & complete DOT format support.

DOT format is not that complicated AND fully-documented, write it 'manually'.

TODO: explain all data structures

"""

import argparse
import re
import sys
from pprint import pprint


debug = False


def get_args():
    """ get arguments from CLI """
    parser = argparse.ArgumentParser(description="""Create DOT GraphViz
                                     topology from ibnetdiscover with
                                     files containing hostnames ('H-GUID hostname' format) and GUID's for spine switches
                                     (only 'S-GUID' format).
                                     """)
    parser.add_argument('-d', '--debug', action='store_true', help='toggle debug on')
    parser.add_argument('topofile', type=str, help='topology file')
    parser.add_argument('-m', '--mapfile', type=str, help='map file', default=None)
    parser.add_argument('-s', '--spinefile', type=str, help='spine file', default=None)
    parser.add_argument('-o', '--output', help='output file, if omitted stdout')
    return parser.parse_args()


def read_map(map_file, debug=None):
    """ return a dict {'GUID': 'hostname'} from the map file"""
    d = {}
    with open(map_file, 'r') as f:
        for line in f:
            l = line.strip()
            if l.startswith('#') or len(l) == 0:
                continue
            (key, val) = line.split()
            d[key] = val
    if debug:
        pprint(d)
    return d


def read_spine(spine_file, debug=None):
    """ return a list ['GUID'] of spine switchs from the spine file"""
    sl = []
    with open(spine_file, 'r') as f:
        for line in f:
            l = line.strip()
            if l.startswith('#') or len(l) == 0:
                continue
            sl.append(l)
    if debug:
        pprint(sl)
    return sl


def speed2weight(speed):
    """Convert an IB speed to an edge weight
    Copyright (C) 2013-2020  Janne Blomqvist
    from ibtopotool, MPL2 license
    See e.g. https://en.wikipedia.org/wiki/InfiniBand
    """
    sub_str = speed.split('x')
    nlinks = int(sub_str[0])
    s1 = sub_str[1]
    if s1 == 'SDR':
        sp = 2
        color = 'red'
    elif s1 == 'DDR':
        sp = 4
        color = 'red'
    elif s1 == 'QDR':
        sp = 8
        color = 'blue'
    elif s1 == 'FDR10':
        sp = 8  # yep, equivalent to QDR, at best
        color = 'red'
    elif s1 == 'FDR':
        sp = 13.64
        color = 'green'
    elif s1 == 'EDR':
        sp = 24.24
        color = 'green'
    elif s1 == 'HDR':
        sp = 50  # roughly??
        color = 'green'
    elif s1 == 'NDR':
        sp = 100  # roughly?
        color = 'green'
    elif s1 == 'XDR':
        sp = 250  # the future?
        color = 'green'
    else:
        raise NotImplementedError('Support for Infiniband speed {} not implemented'.format(s1))
    return (nlinks * sp, color)


def read_topology(topology_file, hostmap=None, spinemap=None, debug=None):
    """ Read topology file as generated by ibnetdiscover, return a big dict """
    topology = {}
    current_node = ''
    with open(topology_file, mode='r', buffering=1) as f:
        for line in f:
            line = line.strip()
            if line:
                # Read the name of nodes and the number of ports (Switches or HCAs)
                m = re.search('^(\w+)\s+(\d+)\s+\"(.+?)\"\s+#\s+\"(.+?)\"', line)
                if m:
                    current_node = m.groups()[2]
                    topology[current_node] = {}
                    topology[current_node]['number_of_ports'] = int(m.groups()[1])
                    topology[current_node]['label'] = m.groups()[3]

                    if m.groups()[0] == 'Switch':
                        topology[current_node]['node_type'] = 'switch'
                        topology[current_node]['label'] = current_node

                        if spinemap:
                            # mark if switch is a spine one
                            if current_node in spinemap:
                                topology[current_node]['switch_type'] = 'spine'
                            else:
                                topology[current_node]['switch_type'] = 'leaf'
                        # if no spinemap, we still need an empty switch_type
                        else:
                                topology[current_node]['switch_type'] = ''

                    else:
                        topology[current_node]['node_type'] = 'hca'

                        if hostmap:
                            # if hca in mapfile, use hostname
                            if current_node in hostmap.keys():
                                hostname = hostmap[current_node]
                                # keep the HBA model
                                label = hostname + " " + m.groups()[3].split()[0]
                                topology[current_node]['label'] = label
                            else:
                                topology[current_node]['label'] = current_node
                        else:
                            topology[current_node]['label'] = current_node

                    topology[current_node]['ports'] = []

                # Read the port lines
                m = re.search('^\[(\d+)\].*?\"(.+?)\"\[(\d+)\]', line)
                if m:
                    local_port = int(m.groups()[0])
                    remote = m.groups()[1]
                    remote_port = int(m.groups()[2])

                    # use speed to determine color and weight
                    weight, color = speed2weight(line.split()[-1])

                    topology[current_node]['ports'].append(
                        (local_port, remote, remote_port, weight, color))
    return topology


def node_label(label, number_of_ports, debug=None):
    """ generate the HTML-like label
    <TABLE ALIGN="CENTER"><TR><TD COLSPAN="2">name</TD></TR>
    <TR>
        <TD PORT="odd">odd</TD>
        <TD PORT="even">even</TD>
    </TR>

    singleport:
    <TR>
        <TD PORT="port">port</TD>
    </TR>

    return a string
    """
    long_string = []
    # name = re.sub(r"[;: ]+", "\\\\n", label)  # LF do not work in HTML-like
    name = re.sub(r'[;: ]+', ' ', label)
    port_range = range(1, number_of_ports + 1)
    long_string.append('<<TABLE ALIGN="CENTER">')
    if number_of_ports % 2 == 1:
        long_string.extend(['<TR>', '<TD>', name, '</TD>', '</TR>'])
        long_string.append('<TR>')
        str_single = '<TD PORT="' + str(number_of_ports) + '">' + str(number_of_ports) + '</TD>'
        long_string.append(str_single)
        long_string.append('</TR>')

    else:
        long_string.extend(['<TR>', '<TD COLSPAN="2">', name, '</TD>', '</TR>'])
        for i in range(number_of_ports // 2):
            long_string.append('<TR>')
            odd = i * 2 + 1
            str_odd = '<TD PORT="' + str(odd) + '">' + str(odd).zfill(2) + '</TD>'
            long_string.append(str_odd)
            even = i * 2 + 2
            str_even = '<TD PORT="' + str(even) + '">' + str(even).zfill(2) + '</TD>'
            long_string.append(str_even)
            long_string.append('</TR>')

    long_string.append('</TABLE>>')

    return ''.join([str(elem) for elem in long_string])


def prepare_dot_structure(topology, debug=None):
    """ Transform the topoly in DOT format, as a list of strings
    (general graph options are in write_dot_file)
    describes nodes,
    then groups (rank=min|same|max),
    then edges, starting with S to S, then S to H,
        deal with color, weight et penwidth.

    return a list
    """
    dot_structure = []
    for node in topology.keys():
        node_info = topology[node]

        label = node_label(node_info['label'], node_info['number_of_ports'])

        node_type = node_info['node_type']
        if node_type == "switch":
            if node_info['switch_type'] == 'spine':
                attr = {
                        'color': 'orange',
                        'fillcolor': 'darkorange',
                        'style': 'filled',
                        'rank': '0',
                        'root': 'true',
                        'shape': 'box',
                        }
            else:
                attr = {
                        'color': 'blue',
                        'fillcolor': 'cyan',
                        'style': 'filled',
                        'rank': '1',
                        'shape': 'box',
                        }
        else: # hca
            attr = {
                    'color': 'grey',
                    'rank': '2',
                    'shape': 'box',
                    }

        # transform dict into list:
        attr_tmp = ', '.join(['{}=\"{}\"'.format(k,v) for (k,v) in attr.items()])
        attr_str = ''.join([attr_tmp, ', label=', label])
        # append to list:
        dot_structure.extend(['  "', node, '" ', ' [', attr_str, '];\n'])
        if debug:
            pprint(dot_structure)

    # spines: minimum rank
    dot_structure.append('{rank="min" ;\n')
    for node in topology.keys():
        node_info = topology[node]
        if node_info['node_type'] == 'switch':
            if node_info['switch_type'] == 'spine':
                dot_structure.extend([' "', node, '" ;\n'])
    dot_structure.append('};\n')

    # other switchs, not spines
    dot_structure.append('{rank="same" ;\n')
    for node in topology.keys():
        node_info = topology[node]
        if node_info['node_type'] == 'switch':
            if node_info['switch_type'] != 'spine':
                dot_structure.extend([' "', node, '" ;\n'])
    dot_structure.append('};\n')

    # then hosts
    dot_structure.append('{rank="max" ;\n')
    for node in topology.keys():
        node_info = topology[node]
        if node_info['node_type'] == 'hca':
            dot_structure.extend([' "', node, '" ;\n'])
    dot_structure.append('};\n')

    # edges
    for node in topology.keys():
        ports = topology[node]['ports']
        node_type = topology[node]['node_type']
        for (local_port, remote, remote_port, weight, color) in ports:
            remote_type = topology[remote]['node_type']

            if node_type == 'switch' and remote_type == 'switch' and color != 'red':
                attr = {
                        'color': 'darkgreen',
                        'arrowhead': 'none',
                        'weight': weight,  # informational only
                        # penwidth=[2 or 3]
                        'penwidth': '3',
                        }
            elif node_type == 'hca' and color == 'red':
                attr = {
                        'color': color,
                        'arrowhead': 'dot',
                        'weight': weight,  # informational only
                        # bad! more penwidth
                        'penwidth': '4',
                        }
            else:
                attr = {
                        'color': color,
                        'arrowhead': 'none',
                        'weight': weight,  # informational only
                        # 'penwidth': '2',
                        }
            # only one edge per connection
            if node + ' ' + str(local_port) < remote + ' ' + str(remote_port):
                attr_str = ', '.join(['{}=\"{}\"'.format(k,v) for (k,v) in attr.items()])

                dot_structure.extend(['  "', node, '":', local_port,
                                     ' -> "',
                                     remote, '":', remote_port,
                                     ' [', attr_str, '];\n',
                                     ])

    return dot_structure


def write_dot_file(dot_structure, output):
    """ """
    # possible displays: rankdir="RL", "TB", splines="compound", "true"
    output.write('digraph IBtopo {\ngraph [rankdir="LR" ; splines="ortho"];\n')
    output.write(''.join([str(elem) for elem in dot_structure]))
    output.write('}\n')


if __name__ == '__main__':
    """ """
    args = get_args()

    if args.debug:
        debug = True
        print(args)

    if args.mapfile:
        hostmap = read_map(args.mapfile, debug=debug)
    else:
        hostmap = None

    if args.spinefile:
        spinemap = read_spine(args.spinefile, debug=debug)
    else:
        spinemap = None

    topology = read_topology(args.topofile, hostmap=hostmap, spinemap=spinemap, debug=debug)
    if debug:
        pprint(topology)

    dot_structure = prepare_dot_structure(topology, debug=debug)
    if debug:
        pprint(dot_structure)

    if args.output:
        with open(args.output, mode='w') as out:
            write_dot_file(dot_structure, out)
    else:
        out = sys.stdout
        write_dot_file(dot_structure, out)
